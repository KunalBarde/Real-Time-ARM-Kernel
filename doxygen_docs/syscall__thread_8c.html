<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>349 RTOS: kernel/src/syscall_thread.c File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen_style.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">349 RTOS </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part --><!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_dc43877d82dd332f9fb2071fcca799d6.html">kernel</a></li><li class="navelem"><a class="el" href="dir_3dd30a497388ee684638f120a124721c.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">syscall_thread.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>System calls used for multithreading purposes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;syscall_thread.h&quot;</code><br />
<code>#include &quot;syscall_mutex.h&quot;</code><br />
<code>#include &quot;syscall.h&quot;</code><br />
<code>#include &quot;mpu.h&quot;</code><br />
<code>#include &lt;debug.h&gt;</code><br />
<code>#include &lt;timer.h&gt;</code><br />
<code>#include &lt;arm.h&gt;</code><br />
<code>#include &lt;printk.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c88edc8d48ce7172e288f14dd6a06d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3c88edc8d48ce7172e288f14dd6a06d6">XPSR_INIT</a>&#160;&#160;&#160;0x1000000</td></tr>
<tr class="memdesc:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial XPSR value, all 0s except thumb bit. <br /></td></tr>
<tr class="separator:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a6ea3d12a6db3f3a0b8afcb52881c2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a8a6ea3d12a6db3f3a0b8afcb52881c2a">LR_RETURN_TO_USER_PSP</a>&#160;&#160;&#160;0xFFFFFFFD</td></tr>
<tr class="memdesc:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt return code to user mode using PSP. <br /></td></tr>
<tr class="separator:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf65de8424a7c25ac572b36b251eb976"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf65de8424a7c25ac572b36b251eb976"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#abf65de8424a7c25ac572b36b251eb976">LR_RETURN_TO_KERNEL_MSP</a>&#160;&#160;&#160;0xFFFFFFF1</td></tr>
<tr class="memdesc:abf65de8424a7c25ac572b36b251eb976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt return code to kernel mode using MSP. <br /></td></tr>
<tr class="separator:abf65de8424a7c25ac572b36b251eb976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f1a9a85716813c62bc2cfaaf1a88df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a45f1a9a85716813c62bc2cfaaf1a88df">MAX_TOTAL_THREADS</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a45f1a9a85716813c62bc2cfaaf1a88df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba34e0374496611ed0ad1d6c12c69840"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aba34e0374496611ed0ad1d6c12c69840">MAX_U_THREADS</a>&#160;&#160;&#160;14</td></tr>
<tr class="separator:aba34e0374496611ed0ad1d6c12c69840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b20d41d6252e9871430c242cb1a56e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a6b20d41d6252e9871430c242cb1a56e7">BUFFER_SIZE</a>&#160;&#160;&#160;<a class="el" href="syscall__thread_8c.html#a45f1a9a85716813c62bc2cfaaf1a88df">MAX_TOTAL_THREADS</a></td></tr>
<tr class="separator:a6b20d41d6252e9871430c242cb1a56e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ed8507d1cd2331ad09275c5c4c1c89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a92ed8507d1cd2331ad09275c5c4c1c89">WORD_SIZE</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a92ed8507d1cd2331ad09275c5c4c1c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3b22f32fd639dd22bbb76ca248b9f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#adc3b22f32fd639dd22bbb76ca248b9f8">TCB_BUFFER_SIZE</a>&#160;&#160;&#160;(sizeof(tcb_t) * (<a class="el" href="uart_8c.html#a6b20d41d6252e9871430c242cb1a56e7">BUFFER_SIZE</a>))</td></tr>
<tr class="separator:adc3b22f32fd639dd22bbb76ca248b9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe78fd82e092286cded01150a302b2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7fe78fd82e092286cded01150a302b2e">I_THREAD_SET_IDX</a>&#160;&#160;&#160;14</td></tr>
<tr class="separator:a7fe78fd82e092286cded01150a302b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c653106823557e94a6a201319056ed7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3c653106823557e94a6a201319056ed7">D_THREAD_SET_IDX</a>&#160;&#160;&#160;15</td></tr>
<tr class="separator:a3c653106823557e94a6a201319056ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41816ab1942f7d02b1bf9cce2d621a80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a41816ab1942f7d02b1bf9cce2d621a80">I_THREAD_PRIORITY</a>&#160;&#160;&#160;14</td></tr>
<tr class="separator:a41816ab1942f7d02b1bf9cce2d621a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41cde0035942afb6226f9ceaad4fcf9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ac41cde0035942afb6226f9ceaad4fcf9">D_THREAD_PRIORITY</a>&#160;&#160;&#160;15</td></tr>
<tr class="separator:ac41cde0035942afb6226f9ceaad4fcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5889105dcd019008c9448dff61323f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ab5889105dcd019008c9448dff61323f6">INIT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ab5889105dcd019008c9448dff61323f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ee57d95da6b6509d43bb1b3f67bb02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a13ee57d95da6b6509d43bb1b3f67bb02">WAITING</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a13ee57d95da6b6509d43bb1b3f67bb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccc5ca21a66634195c2d9964c7817e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7ccc5ca21a66634195c2d9964c7817e8">RUNNABLE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a7ccc5ca21a66634195c2d9964c7817e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb7181d994ee98e735494be55809708"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a6fb7181d994ee98e735494be55809708">RUNNING</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a6fb7181d994ee98e735494be55809708"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a84de83d8cbea30290aab3c7eee772049"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84de83d8cbea30290aab3c7eee772049"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a84de83d8cbea30290aab3c7eee772049">default_idle</a> ()</td></tr>
<tr class="memdesc:a84de83d8cbea30290aab3c7eee772049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default idle function asm stub needed for sleeping the processor when all other threads are waiting. Used if the user idle function exits or is never provided in thread_init. <br /></td></tr>
<tr class="separator:a84de83d8cbea30290aab3c7eee772049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f4984cff982459b6a165f56e86a1cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4f4984cff982459b6a165f56e86a1cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ae4f4984cff982459b6a165f56e86a1cb">_kill</a> ()</td></tr>
<tr class="memdesc:ae4f4984cff982459b6a165f56e86a1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sys_kill asm svc stub. Used for having finished threads automatically call sys_kill on themselves upon returning from their work. <br /></td></tr>
<tr class="separator:ae4f4984cff982459b6a165f56e86a1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ba3ad8a12b82367579d5895804211f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a25ba3ad8a12b82367579d5895804211f">ub_test</a> (float T, float C)</td></tr>
<tr class="memdesc:a25ba3ad8a12b82367579d5895804211f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a UB schedulability test on a new thread being added to the task set.  <a href="#a25ba3ad8a12b82367579d5895804211f">More...</a><br /></td></tr>
<tr class="separator:a25ba3ad8a12b82367579d5895804211f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b092cdef9377874d2a424271fd8e4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2b092cdef9377874d2a424271fd8e4c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ac2b092cdef9377874d2a424271fd8e4c">update_kernel_sets</a> ()</td></tr>
<tr class="memdesc:ac2b092cdef9377874d2a424271fd8e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates kernel ready and waiting set structures to reflect thread states accurately. <br /></td></tr>
<tr class="separator:ac2b092cdef9377874d2a424271fd8e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525baffbc746d9676d45fa131d1b9b7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a525baffbc746d9676d45fa131d1b9b7d">update_thread_states</a> (uint8_t curr_thread)</td></tr>
<tr class="memdesc:a525baffbc746d9676d45fa131d1b9b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responsible for the enforcement of RMS thread states. Will move threads between RUNNABLE and WAITING states as necessary. Will also handle updating bookeeping values associated with each thread.  <a href="#a525baffbc746d9676d45fa131d1b9b7d">More...</a><br /></td></tr>
<tr class="separator:a525baffbc746d9676d45fa131d1b9b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc96a6564aa346ba124293a6604a0427"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc96a6564aa346ba124293a6604a0427"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#abc96a6564aa346ba124293a6604a0427">systick_c_handler</a> ()</td></tr>
<tr class="memdesc:abc96a6564aa346ba124293a6604a0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler called on occassion of sys-tick interrupt. Will call necessary functions to update thread states and then triggers a pendsv interrupt to run the scheduler. <br /></td></tr>
<tr class="separator:abc96a6564aa346ba124293a6604a0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fb597a83ed183c240fb7c9d6e1b3f7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ac2fb597a83ed183c240fb7c9d6e1b3f7">round_robin</a> (void *curr_context_ptr)</td></tr>
<tr class="memdesc:ac2fb597a83ed183c240fb7c9d6e1b3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of round robin scheduler.  <a href="#ac2fb597a83ed183c240fb7c9d6e1b3f7">More...</a><br /></td></tr>
<tr class="separator:ac2fb597a83ed183c240fb7c9d6e1b3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea5383a4af7e9e48e7f21996b50f9d3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3ea5383a4af7e9e48e7f21996b50f9d3">rms</a> (void *curr_context_ptr)</td></tr>
<tr class="memdesc:a3ea5383a4af7e9e48e7f21996b50f9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">RMS scheduler implementation.  <a href="#a3ea5383a4af7e9e48e7f21996b50f9d3">More...</a><br /></td></tr>
<tr class="separator:a3ea5383a4af7e9e48e7f21996b50f9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54a32219d284492dbb7850f0331cb02"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ae54a32219d284492dbb7850f0331cb02">pcp</a> (void *curr_context_ptr)</td></tr>
<tr class="memdesc:ae54a32219d284492dbb7850f0331cb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">PCP scheduler implementation.  <a href="#ae54a32219d284492dbb7850f0331cb02">More...</a><br /></td></tr>
<tr class="separator:ae54a32219d284492dbb7850f0331cb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66dd67d5d707d20135483b2c17b3b89"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ab66dd67d5d707d20135483b2c17b3b89">pendsv_c_handler</a> (void *context_ptr)</td></tr>
<tr class="memdesc:ab66dd67d5d707d20135483b2c17b3b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">PendSV interrupt handler. Runs a scheduler and then dispatches a new thread for running.  <a href="#ab66dd67d5d707d20135483b2c17b3b89">More...</a><br /></td></tr>
<tr class="separator:ab66dd67d5d707d20135483b2c17b3b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf395a32723974af129b9bf11689e8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7cf395a32723974af129b9bf11689e8a">sys_thread_init</a> (uint32_t max_threads, uint32_t stack_size, void *idle_fn, protection_mode memory_protection, uint32_t max_mutexes)</td></tr>
<tr class="memdesc:a7cf395a32723974af129b9bf11689e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">System call to initialize a new thread.  <a href="#a7cf395a32723974af129b9bf11689e8a">More...</a><br /></td></tr>
<tr class="separator:a7cf395a32723974af129b9bf11689e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb03d48542c5c84a2c9d297267e3553a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aeb03d48542c5c84a2c9d297267e3553a">thread_kill</a> (void)</td></tr>
<tr class="separator:aeb03d48542c5c84a2c9d297267e3553a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7456217e2b43c86404a72acac2df684f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7456217e2b43c86404a72acac2df684f">sys_thread_create</a> (void *fn, uint32_t priority, uint32_t C, uint32_t T, void *vargp)</td></tr>
<tr class="memdesc:a7456217e2b43c86404a72acac2df684f"><td class="mdescLeft">&#160;</td><td class="mdescRight">System call to spawn a new thread. Schedulability verified using UB test.  <a href="#a7456217e2b43c86404a72acac2df684f">More...</a><br /></td></tr>
<tr class="separator:a7456217e2b43c86404a72acac2df684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0726d2166701a485c555e6b7f7af3b60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a0726d2166701a485c555e6b7f7af3b60">sys_scheduler_start</a> (uint32_t frequency)</td></tr>
<tr class="memdesc:a0726d2166701a485c555e6b7f7af3b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">System call to begin the rtos scheduler. Pends a PendSV so this function will only return when all previously scheduled user threads have been killed or have terminated.  <a href="#a0726d2166701a485c555e6b7f7af3b60">More...</a><br /></td></tr>
<tr class="separator:a0726d2166701a485c555e6b7f7af3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a8b4f86fe10ac2c90ce8158872aac7ce2">sys_get_priority</a> ()</td></tr>
<tr class="memdesc:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns priority of current running thread.  <a href="#a8b4f86fe10ac2c90ce8158872aac7ce2">More...</a><br /></td></tr>
<tr class="separator:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341334c885696457b6f66bb8acda5b22"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a341334c885696457b6f66bb8acda5b22">sys_get_time</a> ()</td></tr>
<tr class="memdesc:a341334c885696457b6f66bb8acda5b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of system ticks since scheduler was initialized.  <a href="#a341334c885696457b6f66bb8acda5b22">More...</a><br /></td></tr>
<tr class="separator:a341334c885696457b6f66bb8acda5b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8933e910725546aa9e052369db9cf81"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aa8933e910725546aa9e052369db9cf81">sys_thread_time</a> ()</td></tr>
<tr class="memdesc:aa8933e910725546aa9e052369db9cf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of actual execution time consumed by a the current thread.  <a href="#aa8933e910725546aa9e052369db9cf81">More...</a><br /></td></tr>
<tr class="separator:aa8933e910725546aa9e052369db9cf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601e5d8e922ccdec535527e8d8724d78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a601e5d8e922ccdec535527e8d8724d78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a601e5d8e922ccdec535527e8d8724d78">sys_thread_kill</a> ()</td></tr>
<tr class="memdesc:a601e5d8e922ccdec535527e8d8724d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kill the currently running thread. If it is the idle thread, the default thread shall be run instead. If it is the last remaining user thread, the scheduler shall restore to the default thread. <br /></td></tr>
<tr class="separator:a601e5d8e922ccdec535527e8d8724d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3a3fb472158a93e59df836b9935b54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a3a3fb472158a93e59df836b9935b54"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a2a3a3fb472158a93e59df836b9935b54">sys_wait_until_next_period</a> ()</td></tr>
<tr class="memdesc:a2a3a3fb472158a93e59df836b9935b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Have the current thread wait until the next period of execution. <br /></td></tr>
<tr class="separator:a2a3a3fb472158a93e59df836b9935b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d3058e8c4464d614c9506562710e91"><td class="memItemLeft" align="right" valign="top">kmutex_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a12d3058e8c4464d614c9506562710e91">sys_mutex_init</a> (uint32_t max_prio)</td></tr>
<tr class="memdesc:a12d3058e8c4464d614c9506562710e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a mutex.  <a href="#a12d3058e8c4464d614c9506562710e91">More...</a><br /></td></tr>
<tr class="separator:a12d3058e8c4464d614c9506562710e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a6a14ccbc1e43d61617b97ecd06cf65b9">sys_mutex_lock</a> (kmutex_t *mutex)</td></tr>
<tr class="memdesc:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock mutex. Will hang until the mutex has been acquired.  <a href="#a6a14ccbc1e43d61617b97ecd06cf65b9">More...</a><br /></td></tr>
<tr class="separator:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9d6010ec5fc0965665a7070cef0e99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#adc9d6010ec5fc0965665a7070cef0e99">acquire_mutex</a> (uint32_t curr_ceil, uint32_t max_prior, uint8_t mutex_num)</td></tr>
<tr class="memdesc:adc9d6010ec5fc0965665a7070cef0e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper polling function to check if a thread is able to acquire a specific mutex given its current priority.  <a href="#adc9d6010ec5fc0965665a7070cef0e99">More...</a><br /></td></tr>
<tr class="separator:adc9d6010ec5fc0965665a7070cef0e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c82abd2f5ccdd63635261e9cb307a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71c82abd2f5ccdd63635261e9cb307a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a71c82abd2f5ccdd63635261e9cb307a0">raise_blocking_priority</a> (uint32_t curr_ceil)</td></tr>
<tr class="memdesc:a71c82abd2f5ccdd63635261e9cb307a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises blocking thread's inherited priority to match at least current blocked thread's. <br /></td></tr>
<tr class="separator:a71c82abd2f5ccdd63635261e9cb307a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ee2f27a2d7df994f88dc12eb95e072"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a69ee2f27a2d7df994f88dc12eb95e072">find_highest_locked</a> ()</td></tr>
<tr class="memdesc:a69ee2f27a2d7df994f88dc12eb95e072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find max_prior of locked resource with the highest priority;.  <a href="#a69ee2f27a2d7df994f88dc12eb95e072">More...</a><br /></td></tr>
<tr class="separator:a69ee2f27a2d7df994f88dc12eb95e072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3e46dcdb34dcd1fee359bfe9660263"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a5b3e46dcdb34dcd1fee359bfe9660263">find_highest_locker</a> ()</td></tr>
<tr class="memdesc:a5b3e46dcdb34dcd1fee359bfe9660263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find thread ID of thread blocking the resource with the highest priority;.  <a href="#a5b3e46dcdb34dcd1fee359bfe9660263">More...</a><br /></td></tr>
<tr class="separator:a5b3e46dcdb34dcd1fee359bfe9660263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af355d2c3314d95df003e778293a5e2ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#af355d2c3314d95df003e778293a5e2ff">check_no_locks</a> (uint32_t thread_buf_idx)</td></tr>
<tr class="memdesc:af355d2c3314d95df003e778293a5e2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that thread with given thread id does not currently hold any locks.  <a href="#af355d2c3314d95df003e778293a5e2ff">More...</a><br /></td></tr>
<tr class="separator:af355d2c3314d95df003e778293a5e2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a55db4294dd5ed35ee5b2b1b1043ddbdd">sys_mutex_unlock</a> (kmutex_t *mutex)</td></tr>
<tr class="memdesc:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock specific mutex. Will hang until it has been sucessfully unlocked.  <a href="#a55db4294dd5ed35ee5b2b1b1043ddbdd">More...</a><br /></td></tr>
<tr class="separator:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a187e79dd2a6a18d6bbbc4f2509eb668b">ub_table</a> []</td></tr>
<tr class="memdesc:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precalculated values for UB test.  <a href="#a187e79dd2a6a18d6bbbc4f2509eb668b">More...</a><br /></td></tr>
<tr class="separator:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e71551f6fb0af701d53cde99ca3d82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42e71551f6fb0af701d53cde99ca3d82"></a>
volatile char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a42e71551f6fb0af701d53cde99ca3d82">kernel_threading_state</a> [K_BLOCK_SIZE]</td></tr>
<tr class="memdesc:a42e71551f6fb0af701d53cde99ca3d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global threading state. <br /></td></tr>
<tr class="separator:a42e71551f6fb0af701d53cde99ca3d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a965b457902b75612d5c4db04d78cb6e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a965b457902b75612d5c4db04d78cb6e1"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a965b457902b75612d5c4db04d78cb6e1">__thread_u_stacks_low</a></td></tr>
<tr class="memdesc:a965b457902b75612d5c4db04d78cb6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap high and low pointers. <br /></td></tr>
<tr class="separator:a965b457902b75612d5c4db04d78cb6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df5a7143f4fb8f52024cc2eb04d179e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7df5a7143f4fb8f52024cc2eb04d179e"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7df5a7143f4fb8f52024cc2eb04d179e">__thread_u_stacks_top</a></td></tr>
<tr class="memdesc:a7df5a7143f4fb8f52024cc2eb04d179e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap high and low pointers. <br /></td></tr>
<tr class="separator:a7df5a7143f4fb8f52024cc2eb04d179e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1e9fb5e74e0a3280d8d6b74d61146a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed1e9fb5e74e0a3280d8d6b74d61146a"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aed1e9fb5e74e0a3280d8d6b74d61146a">__thread_k_stacks_low</a></td></tr>
<tr class="memdesc:aed1e9fb5e74e0a3280d8d6b74d61146a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap high and low pointers. <br /></td></tr>
<tr class="separator:aed1e9fb5e74e0a3280d8d6b74d61146a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f42f247ccf963d377b87cf4bc2ccca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52f42f247ccf963d377b87cf4bc2ccca"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a52f42f247ccf963d377b87cf4bc2ccca">__thread_k_stacks_top</a></td></tr>
<tr class="memdesc:a52f42f247ccf963d377b87cf4bc2ccca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap high and low pointers. <br /></td></tr>
<tr class="separator:a52f42f247ccf963d377b87cf4bc2ccca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>System calls used for multithreading purposes. </p>
<dl class="section date"><dt>Date</dt><dd>11/13/2020</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Kunal Barde, Nick Toldalagi </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a6b20d41d6252e9871430c242cb1a56e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFER_SIZE&#160;&#160;&#160;<a class="el" href="syscall__thread_8c.html#a45f1a9a85716813c62bc2cfaaf1a88df">MAX_TOTAL_THREADS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread control block buffer size (in number of tcbs) </p>

</div>
</div>
<a class="anchor" id="ac41cde0035942afb6226f9ceaad4fcf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define D_THREAD_PRIORITY&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Priority of default thread </p>

</div>
</div>
<a class="anchor" id="a3c653106823557e94a6a201319056ed7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define D_THREAD_SET_IDX&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default thread index into kernel buffers </p>

</div>
</div>
<a class="anchor" id="a41816ab1942f7d02b1bf9cce2d621a80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I_THREAD_PRIORITY&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Priority of idle thread </p>

</div>
</div>
<a class="anchor" id="a7fe78fd82e092286cded01150a302b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I_THREAD_SET_IDX&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Idle thread index into kernel buffers </p>

</div>
</div>
<a class="anchor" id="ab5889105dcd019008c9448dff61323f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INIT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialization state for a thread </p>

</div>
</div>
<a class="anchor" id="a45f1a9a85716813c62bc2cfaaf1a88df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_TOTAL_THREADS&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum total threads allowed by the system </p>

</div>
</div>
<a class="anchor" id="aba34e0374496611ed0ad1d6c12c69840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_U_THREADS&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of user alloated threads </p>

</div>
</div>
<a class="anchor" id="a7ccc5ca21a66634195c2d9964c7817e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RUNNABLE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runnable state for a thread </p>

</div>
</div>
<a class="anchor" id="a6fb7181d994ee98e735494be55809708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RUNNING&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Running state for thread </p>

</div>
</div>
<a class="anchor" id="adc3b22f32fd639dd22bbb76ca248b9f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCB_BUFFER_SIZE&#160;&#160;&#160;(sizeof(tcb_t) * (<a class="el" href="uart_8c.html#a6b20d41d6252e9871430c242cb1a56e7">BUFFER_SIZE</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread control block buffer size (in bytes) </p>

</div>
</div>
<a class="anchor" id="a13ee57d95da6b6509d43bb1b3f67bb02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WAITING&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waiting state for a thread </p>

</div>
</div>
<a class="anchor" id="a92ed8507d1cd2331ad09275c5c4c1c89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORD_SIZE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>System word size </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="adc9d6010ec5fc0965665a7070cef0e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int acquire_mutex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curr_ceil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mutex_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper polling function to check if a thread is able to acquire a specific mutex given its current priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curr_ceil</td><td>Current static ceiling of acquiring thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_prior</td><td>Max_prior of the the thread to be acquired. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex_num</td><td>Mutex id of the mutex to be acquired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success. 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af355d2c3314d95df003e778293a5e2ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check_no_locks </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thread_buf_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that thread with given thread id does not currently hold any locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_buf_idx</td><td>Thread id of thread to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if no locks. 0 if it does hold a lock. </dd></dl>

</div>
</div>
<a class="anchor" id="a69ee2f27a2d7df994f88dc12eb95e072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t find_highest_locked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find max_prior of locked resource with the highest priority;. </p>
<dl class="section return"><dt>Returns</dt><dd>-1 if no locked mutexes found. Else it is max_prior of the locked mutex with the highest max_prior </dd></dl>

</div>
</div>
<a class="anchor" id="a5b3e46dcdb34dcd1fee359bfe9660263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t find_highest_locker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find thread ID of thread blocking the resource with the highest priority;. </p>
<dl class="section return"><dt>Returns</dt><dd>-1 if no locking thread found. Else it is the thread ID of the thread blocking the mutex with the largest max_priority </dd></dl>

</div>
</div>
<a class="anchor" id="ae54a32219d284492dbb7850f0331cb02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pcp </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>curr_context_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PCP scheduler implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curr_context_ptr</td><td>Pointer to the stack saved context fo the current thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the stack-saved context of the next thread to be run as determined by the PCP algorithm. </dd></dl>

</div>
</div>
<a class="anchor" id="ab66dd67d5d707d20135483b2c17b3b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pendsv_c_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PendSV interrupt handler. Runs a scheduler and then dispatches a new thread for running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context_ptr</td><td>A pointer to the current thread's stack-saved context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next thread's stack-saved context. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ea5383a4af7e9e48e7f21996b50f9d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rms </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>curr_context_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RMS scheduler implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curr_context_ptr</td><td>Pointer to the stack saved context fo the current thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the stack-saved context of the next thread to be run as determined by the RMS algorithm. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2fb597a83ed183c240fb7c9d6e1b3f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* round_robin </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>curr_context_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of round robin scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curr_context_ptr</td><td>Context pointer of current thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PSP of next context to load and run. If there are no more user threads left to run, the default thread's context is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b4f86fe10ac2c90ce8158872aac7ce2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns priority of current running thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Priority of current running thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a341334c885696457b6f66bb8acda5b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of system ticks since scheduler was initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of system ticks since this scheduler was initialized. </dd></dl>

</div>
</div>
<a class="anchor" id="a12d3058e8c4464d614c9506562710e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kmutex_t* sys_mutex_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_prio</td><td>The maximum priority of this mutex. 0 is the highest priority. Will not be checked for validity until thread attempts to lock the mutex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created mutex struct. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a14ccbc1e43d61617b97ecd06cf65b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">kmutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock mutex. Will hang until the mutex has been acquired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Mutex to be acquired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55db4294dd5ed35ee5b2b1b1043ddbdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">kmutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock specific mutex. Will hang until it has been sucessfully unlocked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>Mutex to be unlocked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0726d2166701a485c555e6b7f7af3b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_scheduler_start </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System call to begin the rtos scheduler. Pends a PendSV so this function will only return when all previously scheduled user threads have been killed or have terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frequency</td><td>The frequency (in Hz) at which the the Systick interrupt should fire in order to re-run the scheduler to evaluate the current working pool of threads.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a7456217e2b43c86404a72acac2df684f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_thread_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vargp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System call to spawn a new thread. Schedulability verified using UB test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>Function to be executed by new thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority of new thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>Worst case computation time of new thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>Period of new thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vargp</td><td>Argument to thread function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cf395a32723974af129b9bf11689e8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_thread_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>idle_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">protection_mode&#160;</td>
          <td class="paramname"><em>memory_protection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_mutexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System call to initialize a new thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_threads</td><td>Maximum number of user threads. Cannot be great than 14. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_size</td><td>Stack size for each thread in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idle_fn</td><td>Idle function to be used by scheduler. If NULL a default one shall be utilized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memory_protection</td><td>UNUSED </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_mutexes</td><td>UNUSED</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8933e910725546aa9e052369db9cf81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_thread_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of actual execution time consumed by a the current thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The duration of execution of the current thread. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb03d48542c5c84a2c9d297267e3553a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_kill </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to kill current thread </p>

</div>
</div>
<a class="anchor" id="a25ba3ad8a12b82367579d5895804211f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ub_test </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a UB schedulability test on a new thread being added to the task set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>Period of new Thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>Worst case runtime of new thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if schedulable, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a525baffbc746d9676d45fa131d1b9b7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_thread_states </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>curr_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Responsible for the enforcement of RMS thread states. Will move threads between RUNNABLE and WAITING states as necessary. Will also handle updating bookeeping values associated with each thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr_thread</td><td>Tcb_buffer idx of the currently running thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a187e79dd2a6a18d6bbbc4f2509eb668b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ub_table[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">  0.000, 1.000, .8284, .7798, .7568,</div><div class="line">  .7435, .7348, .7286, .7241, .7205,</div><div class="line">  .7177, .7155, .7136, .7119, .7106,</div><div class="line">  .7094, .7083, .7075, .7066, .7059,</div><div class="line">  .7052, .7047, .7042, .7037, .7033,</div><div class="line">  .7028, .7025, .7021, .7018, .7015,</div><div class="line">  .7012, .7009</div><div class="line">}</div></div><!-- fragment -->
<p>Precalculated values for UB test. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
</body>
</html>
